\documentclass[14pt]{beamer}
\usetheme{Antibes}
  %\definecolor{myOrange}{RGB}{142,155,206}
\definecolor{myOrange}{RGB}{41,108,172}
\setbeamercolor*{palette primary}{fg=myOrange}
\setbeamercolor*{palette secondary}{fg=myOrange,bg=white}
\setbeamercolor*{palette tertiary}{bg=myOrange,fg=white}
\setbeamercolor*{titlelike}{parent=palette primary}
\setbeamercolor*{itemize item}{fg=myOrange}
\setbeamercolor{block title example}{bg=myOrange} 
\setbeamercolor{section in toc}{fg=black}
\setbeamertemplate{sections/subsections in toc}[sections numbered]
\setbeamercolor{section number projected}{bg=myOrange,fg=yellow}
\setbeamertemplate{footline}[frame number]
\setbeamertemplate{frametitle}{
  \begin{centering}
  \insertframetitle
    \par
    \end{centering}
}
\setbeamertemplate{itemize item}{\textbullet}

\usepackage{amsmath}
\usepackage{alltt}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{graphicx}
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc
\definecolor{javalinenumbers}{RGB}{79,80,81} % linenumbers
\definecolor{grey}{rgb}{0.95,0.95,0.95}
\lstset{language=Java,
basicstyle=\ttfamily \footnotesize,
keywordstyle=\color{myOrange}\textbf,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numberstyle=\color{javalinenumbers}\tiny,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false,
breaklines=true,
firstnumber=100,
backgroundcolor=\color{grey},
emph={
  val, var, def
},
emphstyle=\color{myOrange}\bfseries,
}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage[absolute,overlay]{textpos}
\logo{\includegraphics[width=2cm]{logo.png}}
\newcommand\B{\rule[-1.7ex]{0pt}{0pt}}
\def\colored#1{\textcolor{myOrange}{#1}}

\setcounter{tocdepth}{1}

\begin{document}
\title{Java mapping for pragmatic programmers}

\newcommand{\smaller}[1] {
  {\scriptsize {#1}}
}

\begin{frame}[t]
    \titlepage
    \begin{textblock*}{20mm}(0mm,5cm)%
      \includegraphics[width=35mm]{start1.png}
    \end{textblock*}
\end{frame}

\begin{frame}[t]
    \titlepage
    \begin{textblock*}{20mm}(0mm,5cm)%
      \includegraphics[width=35mm]{start2.png}
    \end{textblock*}
    \begin{textblock*}{20mm}(0.5\textwidth,3cm)%
      \includegraphics[width=6cm]{stamp.png}
    \end{textblock*}
\end{frame}


\frame
{\frametitle{Disclaimer}
\begin{itemize}
  \item<1> I'm not a Scala expert.
  \item<1> Actually, I do not know Scala at all.
  \item<1> Lets discuss today not implementations, but ideas staying behind them.
\end{itemize}
}

\frame%
{\frametitle{Agenda}
  \tableofcontents[1]
}

\section{Express Scala Course}
\subsection{Express Scala Course}
\frame{
\frametitle{Express Scala Course}
\begin{itemize}
  \item Not a full Scala description
  \item Not a functional programming course
  \item The main task of ``course'' is to help read Scala code, not write
  \item Java8 is recommended background
\end{itemize}
}


\subsection{Declarations}
\begin{frame}[t,fragile]
  \begin{columns}
    \begin{column}[t]{0.45\textwidth}
\centering \Large \colored{Java} \\
    \begin{center}
\begin{lstlisting}[frame=single]
final String a = "a";
String b = "b";

void setC(C c) {
  this.c = c;
}

int inc(int a) {
  return a + 1;
}

\end{lstlisting} 
    \end{center}
    \end{column}
    \begin{column}[t]{0.45\textwidth}
\centering \Large \colored{Scala} \\
    \pause
    \begin{center}
\begin{lstlisting}[frame=single]
val a : String = "a"
var b = "b"

def setC(c:C):Unit = 
{
  this.c = c;
}

def inc(a:Int) = a+1
\end{lstlisting}
    \end{center}

    \end{column}
  \end{columns}
\end{frame}

\subsection{Functions and generics}
\begin{frame}[t,fragile]
  \begin{columns}
    \begin{column}[t]{0.45\textwidth}
\centering \Large \colored{Java} \\
    \begin{center}
\begin{lstlisting}[frame=single]
List<A> list = 
  new ArrayList<>();

int l = list.size();

int[] arr;
int x = arr[5];

list.filter(
  a -> a.hasB()
).map(a -> new B(a))
\end{lstlisting} 
    \end{center}
    \end{column}
    \begin{column}[t]{0.45\textwidth}
\centering \Large \colored{Scala} \\
    \pause
    \begin{center}
\begin{lstlisting}[frame=single]
val list : List[A] = 
  new ArrayList[A]()

val l = list.size

var arr : Array[Int]
val x: Int = arr(5)

list
.filter(_.hasB)
.map(a => new B(a))
\end{lstlisting}
    \end{center}

    \end{column}
  \end{columns}
\end{frame}

\section{Parser combinators (xRools)}
\frame
{\frametitle{xRools}
\begin{itemize}
  \item Written by Scala experts from Kiev
  \item XPath like DSL
  \item Extendable by Scala code
  \item XML oriented
\end{itemize}
}

\frame
{\frametitle{xRools}
\begin{center}
  \large Talk is cheap. Show me the code.
\end{center}
}

\subsection{xRools Pros}
\frame
{\frametitle{xRools Pros}
\begin{itemize}
    \item<1> Scala
    \item<1> Non-developers write rules
    \item<1> Dashboard 
\end{itemize}
}

\subsection{xRools Cons}
\frame
{\frametitle{xRools Cons}
\begin{itemize}
    \item<1> Scala
    \item<1> Non-developers write rules
    \item<1> No compile-time checks
    \item<1> Uses reflection
    \item<1> No real IDE support
    \item<1> Functions defined away from its only usage
    \item<1> Debugging?
\end{itemize}
}

\subsection{xRools}
\frame
{\frametitle{xRools}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{xrools.jpeg}
  \end{center}
}

\section{JAXB plugin} 
\subsection{JAXB plugin}
\frame{
\frametitle{JAXB plugin}
\begin{itemize}
  \item Written by Sergey Armensky \\ (idea of Andrey Vytnov?)
  \item Plain Java (new method added for each property)
  \item Will be soon in production
  \item Have nothing to do with Scala
\end{itemize}
}

\frame
{\frametitle{JAXB plugin}
\begin{center}
  \large Talk is cheap. Show me the code.
\end{center}
}

\subsection{JAXB plugin Pros}
\frame{
\frametitle{JAXB plugin Pros}
\begin{itemize}
  \item<1> Pure Java
  \item<1> Simple and clean
  \item<1> Simplify some code
\end{itemize}
}

\subsection{JAXB plugin Cons}
\frame{
\frametitle{JAXB plugin Cons}
\begin{itemize}
  \item<1> Only for JAXB generated classes
  \item<1> Simplify only some code
  \item<1> Not declarative enough
  \item<1> Not mapper at all
\end{itemize}
}

\subsection{Can we do better?}
\frame{
\frametitle{JAXB Plugin}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{jaxb.jpg} 
  \end{center}
}

\frame{
\frametitle{Can we do better?}
  \begin{center} 
    \only<1> {
      \includegraphics[width=0.4\textwidth]{yajom.jpg} 
      \\~\\
      \large \textbf{CHALLENGE ACCEPTED}
    }
  \end{center}
}

\section{Scala Macros (yajom)}
\subsection{Scala related features}
\frame
{\frametitle{Scala related features}
\begin{itemize}
  \item Implicits of all kinds
  \item Point-free style
  \item Scala virtualized
  \item Macros
\end{itemize}
}

\subsection{Yajom}
\frame
{\frametitle{Yajom}
\begin{itemize}
  \item Yet Another Java Object Mapper
  \item Based on implicits and Scala macros
  \item All reflection is done in compile-time
  \item Easy to configure, extend or derive \\ (having no clue about Scala Macros at all)
\end{itemize}
}

\subsection{Code organisation}
\frame
{\frametitle{Philosoraptor}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{phil.png}
  \end{center}
}

\begin{frame}[t,fragile]
\frametitle{Java with JAXB plugin}
\begin{lstlisting}[numbers=left,xleftmargin=20pt]
A a = from.getA();
if (from.isVerySpecial()) {
  B b = defaultB;
  if (a != null) {
    B realB = a.getB();
    if (realB != null)
      b = realB; 
  } 
  to.c().setB(b);
}
\end{lstlisting}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Option-based yajom}
\begin{lstlisting}[numbers=left,xleftmargin=20pt]
val option = {
  val a = from.getA
  if (from.isVerySpecial) {
    var b = defaultB
    if (a != null) {
      val realB = a.getB
      if (realB != null)
        b = realB
    }
    Some(b)
  } else None
}
yajomOption(to.getC.setB)(option)
\end{lstlisting}
\end{frame}


\begin{frame}[t,fragile]
\frametitle{Option-based yajom}
\begin{lstlisting}[numbers=left,xleftmargin=20pt]
yajomOption(to.getC.setB) {
  val a = from.getA
  if (from.isVerySpecial) {
    var b = defaultB
    if (a != null) {
      val realB = a.getB
      if (realB != null)
        b = realB
    }
    Some(b)
  } else
    None
}
\end{lstlisting}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Option-based yajom with maybe}
\begin{lstlisting}[numbers=left,xleftmargin=20pt]
yajomOption(to.getC.setB) {
  if (from.isVerySpecial) {
    val b = maybe(from.getA.getB)
    Some(b.getOrElse(defaultB))
  } else
    None
}
\end{lstlisting}
\end{frame}

\frame
{\frametitle{Yajom}
\begin{center}
  \large Talk is cheap. Show me the code.
\end{center}
}

\subsection{Yajom Pros}
\frame{
\frametitle{Yajom Pros}
\begin{itemize}
  \item<1> Scala
  \item<1> Compile-time bulletproof
  \item<1> IDE support
  \item<1> Works with any classes without any changes
  \item<1> No problem with debugging
\end{itemize}
}

\subsection{Yajom Cons}
\frame{
\frametitle{Yajom Cons}
\begin{itemize}
  \item<1> Scala
  \item<1> Maybe not mature enough
  \only<1>{
    \begin{textblock*}{35mm}(0.8\textwidth,45mm)%
      \includegraphics[width=35mm]{troll.png}
    \end{textblock*}
  }
\end{itemize}
}

\frame{\frametitle{Yajom}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{optocat.png}  \\
    \large \href{https://github.com/gark87/yajom}{https://github.com/gark87/yajom}
  \end{center}
}

\section{Q\&A, Discussion}
\frame{
  \begin{center}
    \Large Thank You!
  \end{center}
}

\end{document}
